// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.2.0
// - protoc             v3.21.2
// source: api/software/v1/software.proto

package v1

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// SoftwareClient is the client API for Software service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type SoftwareClient interface {
	CreateSoftware(ctx context.Context, in *CreateSoftwareRequest, opts ...grpc.CallOption) (*CreateSoftwareReply, error)
	UpdateSoftware(ctx context.Context, in *UpdateSoftwareRequest, opts ...grpc.CallOption) (*UpdateSoftwareReply, error)
	DeleteSoftware(ctx context.Context, in *DeleteSoftwareRequest, opts ...grpc.CallOption) (*DeleteSoftwareReply, error)
	GetSoftware(ctx context.Context, in *GetSoftwareRequest, opts ...grpc.CallOption) (*GetSoftwareReply, error)
	ListSoftware(ctx context.Context, in *ListSoftwareRequest, opts ...grpc.CallOption) (*ListSoftwareReply, error)
}

type softwareClient struct {
	cc grpc.ClientConnInterface
}

func NewSoftwareClient(cc grpc.ClientConnInterface) SoftwareClient {
	return &softwareClient{cc}
}

func (c *softwareClient) CreateSoftware(ctx context.Context, in *CreateSoftwareRequest, opts ...grpc.CallOption) (*CreateSoftwareReply, error) {
	out := new(CreateSoftwareReply)
	err := c.cc.Invoke(ctx, "/api.software.v1.Software/CreateSoftware", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *softwareClient) UpdateSoftware(ctx context.Context, in *UpdateSoftwareRequest, opts ...grpc.CallOption) (*UpdateSoftwareReply, error) {
	out := new(UpdateSoftwareReply)
	err := c.cc.Invoke(ctx, "/api.software.v1.Software/UpdateSoftware", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *softwareClient) DeleteSoftware(ctx context.Context, in *DeleteSoftwareRequest, opts ...grpc.CallOption) (*DeleteSoftwareReply, error) {
	out := new(DeleteSoftwareReply)
	err := c.cc.Invoke(ctx, "/api.software.v1.Software/DeleteSoftware", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *softwareClient) GetSoftware(ctx context.Context, in *GetSoftwareRequest, opts ...grpc.CallOption) (*GetSoftwareReply, error) {
	out := new(GetSoftwareReply)
	err := c.cc.Invoke(ctx, "/api.software.v1.Software/GetSoftware", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *softwareClient) ListSoftware(ctx context.Context, in *ListSoftwareRequest, opts ...grpc.CallOption) (*ListSoftwareReply, error) {
	out := new(ListSoftwareReply)
	err := c.cc.Invoke(ctx, "/api.software.v1.Software/ListSoftware", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// SoftwareServer is the server API for Software service.
// All implementations must embed UnimplementedSoftwareServer
// for forward compatibility
type SoftwareServer interface {
	CreateSoftware(context.Context, *CreateSoftwareRequest) (*CreateSoftwareReply, error)
	UpdateSoftware(context.Context, *UpdateSoftwareRequest) (*UpdateSoftwareReply, error)
	DeleteSoftware(context.Context, *DeleteSoftwareRequest) (*DeleteSoftwareReply, error)
	GetSoftware(context.Context, *GetSoftwareRequest) (*GetSoftwareReply, error)
	ListSoftware(context.Context, *ListSoftwareRequest) (*ListSoftwareReply, error)
	mustEmbedUnimplementedSoftwareServer()
}

// UnimplementedSoftwareServer must be embedded to have forward compatible implementations.
type UnimplementedSoftwareServer struct {
}

func (UnimplementedSoftwareServer) CreateSoftware(context.Context, *CreateSoftwareRequest) (*CreateSoftwareReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateSoftware not implemented")
}
func (UnimplementedSoftwareServer) UpdateSoftware(context.Context, *UpdateSoftwareRequest) (*UpdateSoftwareReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateSoftware not implemented")
}
func (UnimplementedSoftwareServer) DeleteSoftware(context.Context, *DeleteSoftwareRequest) (*DeleteSoftwareReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteSoftware not implemented")
}
func (UnimplementedSoftwareServer) GetSoftware(context.Context, *GetSoftwareRequest) (*GetSoftwareReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetSoftware not implemented")
}
func (UnimplementedSoftwareServer) ListSoftware(context.Context, *ListSoftwareRequest) (*ListSoftwareReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListSoftware not implemented")
}
func (UnimplementedSoftwareServer) mustEmbedUnimplementedSoftwareServer() {}

// UnsafeSoftwareServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to SoftwareServer will
// result in compilation errors.
type UnsafeSoftwareServer interface {
	mustEmbedUnimplementedSoftwareServer()
}

func RegisterSoftwareServer(s grpc.ServiceRegistrar, srv SoftwareServer) {
	s.RegisterService(&Software_ServiceDesc, srv)
}

func _Software_CreateSoftware_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateSoftwareRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SoftwareServer).CreateSoftware(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.software.v1.Software/CreateSoftware",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SoftwareServer).CreateSoftware(ctx, req.(*CreateSoftwareRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Software_UpdateSoftware_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateSoftwareRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SoftwareServer).UpdateSoftware(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.software.v1.Software/UpdateSoftware",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SoftwareServer).UpdateSoftware(ctx, req.(*UpdateSoftwareRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Software_DeleteSoftware_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteSoftwareRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SoftwareServer).DeleteSoftware(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.software.v1.Software/DeleteSoftware",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SoftwareServer).DeleteSoftware(ctx, req.(*DeleteSoftwareRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Software_GetSoftware_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetSoftwareRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SoftwareServer).GetSoftware(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.software.v1.Software/GetSoftware",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SoftwareServer).GetSoftware(ctx, req.(*GetSoftwareRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Software_ListSoftware_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListSoftwareRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SoftwareServer).ListSoftware(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.software.v1.Software/ListSoftware",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SoftwareServer).ListSoftware(ctx, req.(*ListSoftwareRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Software_ServiceDesc is the grpc.ServiceDesc for Software service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Software_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "api.software.v1.Software",
	HandlerType: (*SoftwareServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateSoftware",
			Handler:    _Software_CreateSoftware_Handler,
		},
		{
			MethodName: "UpdateSoftware",
			Handler:    _Software_UpdateSoftware_Handler,
		},
		{
			MethodName: "DeleteSoftware",
			Handler:    _Software_DeleteSoftware_Handler,
		},
		{
			MethodName: "GetSoftware",
			Handler:    _Software_GetSoftware_Handler,
		},
		{
			MethodName: "ListSoftware",
			Handler:    _Software_ListSoftware_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "api/software/v1/software.proto",
}
